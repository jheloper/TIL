# 자바 스레드-1

멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 의미하는데, 멀티 태스킹이 반드시 멀티 프로세스를 뜻하지는 않음. 하나의 프로세스가 두 가지 이상의 작업을 처리할 수 있는 이유는 멀티 스레드에 있음.

하나의 스레드는 하나의 코드 실행 흐름. 멀티 프로세스가 애플리케이션 단위의 멀티 태스킹이라면 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라 할 수 있음.

각각의 프로세스들은 메모리 영역을 따로 할당받아 사용하기 때문에 하나의 프로세스에서 오류가 발생해도 다른 프로세스에게 영향을 끼치지 않음. 하지만 스레드는 하나의 프로세스 내부에서 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에게 영향을 미치게 됨. 따라서 멀티 스레드에서는 예외 처리에 만전을 기해야 함.

멀티 스레드는 다양한 곳에서 사용됨.

- 대용량 데이터 처리 시간 절약을 위해 데이터를 분할하여 병렬로 처리할 때
- UI를 가지고 있는 애플리케이션에서 네트워크 통신할 때
- 다수 클라이언트의 요청을 처리하는 서버를 개발할 때



## 메인 스레드

모든 자바 애플리케이션은 메인 스레드가 `main()` 메서드를 실행하면서 시작됨.

메인 스레드는 필요에 따라 작업 스레드들을 생성하여 병렬로 코드를 실행할 수 있음.

싱글 스레드 애플리케이션은 메인 스레드가 종료되면 프로세스도 종료됨. 하지만 멀티 스레드 애플리케이션은 메인 스레드가 아니더라도 실행 중인 스레드가 하나라도 있다면 프로세스가 종료되지 않음.



## 작업 스레드 생성과 실행

자바에서는 작업 스레드도 객체로 생성되기 때문에 `java.lang.Thread` 클래스를 직접 객체화해서 생성하거나, `Thread` 클래스를 상속한 하위 클래스를 만들어 생성할 수 있음.

### Thread 클래스로부터 직접 생성

`Thread` 클래스로부터 작업 스레드 객체를 생성하려면 `Runnable` 을 파라미터로 갖는 생성자를 호출해야 함.

```java
Thread thread = new Thread(Runnable target);
```

`Runnable`은 작업 스레드 객체가 실행할 수 있는 코드를 가지고 있는 객체를 구현하기 위한 인터페이스 타입. `Runnable`에는 `run()` 메서드가 정의되어 있으며, 구현 클래스는 `run()`을 재정의해서 작업 스레드가 실행할 코드를 구현해야 함.

```java
class Task implements Runnable {
    public void run() {
        ...
    }
}
```

`Thread` 생성자 호출 시 `Runnable` 익명 객체를 사용할 수 있음.

```java
Thread thread = new Thread(new Runnable() {
    public void run() {
        ...
    }
});
```

`Runnable`은 `run()` 메서드 하나만 정의되어 있기 때문에 함수적 인터페이스. 따라서 람다식을 사용할 수 있음.

```java
Thread thread = new Thread(() -> {
    ...
});
```

작업 스레드는 생성 즉시 실행되는 것이 아니라, `start()` 메서드가 호출되어야 실행됨.

### Thread 하위 클래스로부터 생성

작업 스레드가 실행할 작업을 `Runnable`로 만들지 않고 `Thread`의 하위 클래스로 작업 스레드를 정의하면서 실행할 작업 내용을 포함시킬 수 있음.

`Thread` 클래스를 상속한 후 `run()` 메서드를 재정의해서 작업 스레드가 실행할 코드를 작성.

```java
public class WorkerThread extends Thread {
    @Override
    public void run() {
        ...
    }
}

Thread thread = new WorkerThread();
```

`Thread` 익명 객체로 작업 스레드 객체를 생성할 수 있음.

```java
Thread thread = new Thread() {
    public void run() {
        ...
    }
};
```

### 스레드의 이름

스레드는 자신의 이름을 가지고 있음. 디버깅할 때 어떤 스레드가 작업을 하는지 조사할 목적으로 간혹 사용함. 작업 스레드의 경우 자동으로 이름이 설정되나, `Thread` 클래스의 `setName()` 메서드를 사용해 스레드의 이름을 설정할 수 있음.

`Thread` 클래스의 `getName()` 메서드를 사용하면 스레드의 이름을 얻을 수 있음.

`Thread thread = Thread.currentThread();` 를 사용하여 현재 스레드의 참조를 얻을 수 있음.



## 스레드 우선순위

멀티 스레드는 동시성(Concurrency) 또는 병렬성(Parallelism)으로 실행됨.

동시성은 다중 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질을 뜻하고, 병렬성은 다중 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질을 뜻함.

스레드의 개수가 코어의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가를 결정해야 하는데, 이것을 스레드 스케줄링이라고 함. 스레드 스케줄링에 의해 스레드들은 짧은 시간에 번갈아가며 각각의 `run()` 메서드를 조금씩 실행함.

자바의 스레드 스케줄링은 우선순위 방식과 순환 할당 방식을 사용함. 스레드 우선순위 방식은 스레드 객체에 우선순위 번호를 부여할 수 있기 때문에 개발자가 코드로 제어할 수 있음. 하지만 순환 할당 방식은 JVM에 의해 정해지기 때문에 코드로 제어할 수 없음.

우선순위 방식에서는 우선순위를 1~10 중에서 부여하며, 1이 가장 낮고 10이 가장 높은 우선순위를 가짐. 우선순위를 부여하지 않은 경우 기본적으로 5의 우선순위를 가짐. 우선순위를 변경하고 싶다면 `Thread` 클래스의 `setPriority()` 메서드를 사용해야 함.

```java
thread.setPriority(7);
thread.setPriority(Thread.MAX_PRIORITY); // 10
thread.setPriority(Thread.NORM_PRIORITY); // 5
thread.setPriority(Thread.MIN_PRIORITY); // 1
```

 스레드의 개수가 코어의 개수보다 적을 경우는 우선순위 방식이 크게 영향을 끼치지 못하는데, 멀티 스레드를 병렬성으로 실행할 수 있기 때문.



## 동기화 메서드와 동기화 블럭

멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업할 경우 다른 스레드가 객체의 상태를 변경할 수 있기 때문에 의도치 않은 결과가 나올 수 있음.

스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어 사용할 수 없도록 해야 함. 멀티 스레드 프로그램에서 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역이라고 하는데, 자바에서는 임계 영역을 지정하기 위해 동기화(synchronized) 메서드와 동기화 블럭을 제공함.

동기화 메서드를 만드는 방법은 메서드 선언에 synchronized 키워드를 붙이면 됨. synchronized 키워드는 인스턴스와 정적 메서드 어디든 붙일 수 있음.

```java
public synchronized void method() {
    ...
}
```

동기화 메서드는 실행하는 즉시 객체에 잠금이 일어나고, 스레드가 동기화 메서드를 실행 종료하면 잠금이 풀림. 메서드 전체가 아닌 일부 내용만 임계 영역으로 만들고 싶다면 동기화 블럭을 만들면 됨.

```java
public void method() {
    ...
    synchronized(공유객체) {
        ...
    }
    ...
}
```

동기화 블럭의 외부 코드들은 여러 스레드가 동시에 실행할 수 있지만 동기화 블럭의 내부 코드는 임계 영역이므로 한 번에 한 스레드만 실행 가능함.

만약 하나의 객체에 동기화 메서드와 동기화 블럭이 여러 개 있을 경우, 스레드가 이들 중 하나를 실행할 때 다른 스레드는 객체의 해당 메서드는 물론 다른 동기화 메서드 및 블럭도 실행할 수 없음. 하지만 일반 메서드는 실행 가능함.



## 스레드 상태

자바의 `Thread` 클래스는 자바 5부터 스레드의 상태를 확인할 수 있도록 `getState()` 메서드가 추가됨. `getState()` 메서드는 스레드 상태에 따라 다음과 같은 `Thread.State` 열거 상수를 반환함.

| 상태      | 열거 상수     | 설명                                                         |
| --------- | ------------- | ------------------------------------------------------------ |
| 객체 생성 | NEW           | 스레드 객체가 생성, 아직 start() 메서드가 호출되지 않은 상태. |
| 실행 대기 | RUNNABLE      | 실행 상태로 언제든지 갈 수 있는 상태.                        |
| 일시 정지 | WAITING       | 다른 스레드가 통지할 때까지 기다리는 상태.                   |
|           | TIMED_WAITING | 주어진 시간 동안 기다리는 상태.                              |
|           | BLOCKED       | 사용하고자 하는 객체의 잠금이 풀릴 때까지 기다리는 상태.     |
| 종료      | TERMINATED    | 실행을 마친 상태.                                            |



## 스레드 상태 제어

실행 중인 스레드의 상태를 변경하는 것을 스레드 상태 제어라고 함.

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| interrupt()                                                  | 일시 정지 상태의 스레드에서 interruptedException 예외를 발생시켜, <br />예외 처리 코드에서 실행 대기 상태로 가거나 종료 상태로 갈 수 있도록 함. |
| notify()<br />notifyAll()                                    | 동기화 블럭 내에서 wait() 메서드에 의해 일시 정지 상태에 있는 스레드를 <br />실행 대기 상태로 만듬. |
| resume()                                                     | suspend() 메서드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만듬(Deprecated). |
| sleep(long millis)<br />sleep(long millis, int nanos)        | 주어진 시간 동안 스레드르 일시 정지 상태로 만듬. 주어진 시간이 지나면 <br />자동으로 실행 대기 상태가 됨. |
| join()<br />join(long millis)<br />join(long millis, int nanos) | join() 메서드를 호출한 스레드는 일시 정지 상태가 됨. <br />실행 대기 상태로 가려면 join() 메서드를 멤버로 가지는 스레드가 종료되거나,<br />파라미터로 주어진 시간이 지나야 함. |
| wait()<br />wait(long millis)<br />wait(long millis, int nanos) | 동기화 블럭 내에서 스레드를 일시 정지 상태로 만듬. <br />파라미터로 주어진 시간이 지나면 자동으로 실행 대기 상태가 됨. <br />시간이 주어지지 않으면 notify(), notifyAll() 메서드에 의해 실행 대기 상태로 갈 수 있음. |
| suspend()                                                    | 스레드를 일시 정지 상태로 만듬.<br />resume() 메서드를 호출하면 다시 실행 대기 상태가 됨(Deprecated). |
| yield()                                                      | 실행 중에 우선순위가 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 됨. |
| stop()                                                       | 스레드를 즉시 종료시킴(Deprecated).                          |

### 일정 시간 동안 일시 정지 : sleep()

스레드를 일정 시간 동안 일시 정지하고 싶다면 `Thread` 클래스의 정적 메서드인 `sleep()`을 사용하면 됨.

```java
try {
    Thread.sleep(1000); // 1000 millisecond
} catch (InterruptedException e) {
    ...
}
```

일시 정지 상태에서 파라미터로 주어진 시간이 되기 전에 `interrupt()` 메서드가 호출되면 InterruptedException이 발생하기 때문에 예외 처리가 필요함.

### 다른 스레드에게 실행 양보 : yield()

스레드가 무의미한 반복을 계속하는 것보다 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 가는 것이 전체 프로그램 성능에 도움이 됨. 이런 기능을 위해서 `yield()` 메서드가 사용됨. `yield()` 메서드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드에게 실행 기회를 가질 수 있도록 함.

### 다른 스레드의 종료를 대기 : join()

기본적으로 스레드는 다른 스레드와 독립적으로 실행하나, 다른 스레드의 종료를 기다렸다가 실행해야 하는 경우도 있음. 이런 경우 `join()` 메서드를 사용함. 예를 들어 A 스레드 내에서 B 스레드의 `join()` 메서드를 호출했다면, B 스레드의 실행이 끝날 때까지 일시 정지 상태가 되고, B 스레드의 실행이 끝나면 A 스레드는 다시 실행 상태가 됨.

### 스레드 간 협업 : wait(), notify(), notifyAll()

스레드 간에 교대 작업이 필요한 경우, 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주기 위해서 `notify()` 메서드를 호출하고, 자신을 일시 정지 상태로 만들기 위해 `wait()` 메서드를 호출함. `wait()` 메서드에 파라미터를 지정할 경우 지정 시간이 지난 후 자동으로 실행 대기 상태가 됨. `notifyAll()` 메서드는 일시 정지된 모든 스레드들을 실행 대기 상태로 전환홤. 위 메서드들은 `Thread` 클래스가 아닌 `Object` 클래스에 선언되어 있으므로 모든 공유 객체에서 호출이 가능함. 주의할 점은 이 메서드들은 동기화 메서드 또는 동기화 블럭 내에서만 사용할 수 있다는 것.

### 스레드의 안전한 종료 : stop 플래그, interrupt()

스레드는 자신의 `run()` 메서드를 모두 실행하면 자동으로 종료됨. 경우에 따라서 실행 중인 스레드를 즉시 종료할 필요가 있는데, `Thread` 클래스의 `stop()` 메서드를 사용해서 종료할 수 있었으나 `stop()` 메서드로 스레드를 갑자기 종료하면 사용 중이던 자원들이 불완전한 상태로 남기 때문에 deprecated 됨. 따라서 다음과 같은 방법으로 스레드를 종료시킴.

#### stop 플래그

boolean 값을 가지는 stop 플래그 필드를 하나 만들어 반복문 조건으로 stop 플래그가 true인 경우 스레드가 사용 중인 자원을 정리하고 `run()` 메서드 실행을 완료하여 스레드를 안전하게 종료.

#### interrupt() 메서드

`interrupt()` 메서드는 스레드가 일시 정지 상태일 때 InterruptedException 예외를 발생시킴. 여기서 주의할 점은 스레드가 실행 대기 또는 실행 상태에 있을 때 `interrupt()` 메서드가 실행된다고 해서 즉시 예외가 발생하는 것이 아니라, 스레드가 일시 정지 상태가 되었을 때 예외가 발생한다는 점.

일시 정지 상태가 아닐 때에도 `interrupt()` 메서드 호출 여부를 알 수 있음. `interrupted()` 메서드, 또는 `isInterrupted()` 메서드는 인터럽트 여부에 따라 boolean 값을 반환함. 차이점은 `interrupted()` 메서드는 `Thread` 클래스의 정적 메서드, `isInterrupted()` 메서드는 인스턴스 메서드라는 것.

