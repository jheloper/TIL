# 자바 참조타입



## 메모리 사용 영역

JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)를 다음과 같은 세부 영역으로 구분해서 사용함.

### 메서드 영역

메서드 영역에는 코드에서 사용하는 클래스(.class)들을 클래스 로더로 읽어 클래스별로 런타임 상수풀, 필드 데이터, 메서드 데이터, 메서드 코드, 생성자 코드 등을 분류해서 저장함. **메서드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유함**.

### 힙 영역

힙 영역은 **객체와 배열이 생성**되는 영역. 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조함. 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 JVM은 가비지 컬렉터를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거함. 자바는 코드로 객체를 직접 제거하는 방법을 제공하지 않음.

### JVM 스택 영역

JVM 스택 영역은 **각 스레드마다 하나씩 존재**하며 스레드가 시작될 때 할당됨. 자바 프로그램에서 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하므로 JVM 스택도 하나임.

JVM 스택은 메서드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메서드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행함. 예외 발생 시 `printStackTrace()` 메서드로 보여주는 Stack Trace 각 라인은 하나의 프레임을 표현함.

프레임 내부에는 로컬 변수 스택이 있는데 기본 타입 변수와 참조 타입 변수가 추가되거나 제거됨. 변수가 이 영역에 생성되는 시점은 초기화, 즉 최초로 변수에 값이 저장될 때임. 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거됨.



## 참조 변수의 ==, != 연산

==, != 연산은 변수의 값이 같은지 아닌지를 비교하지만, 참조 변수의 경우 변수의 값이 힙 영역의 객체 주소이므로 결국 주소 값을 비교하는 것이 됨.



## null과 NullPointerException

참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 의미로 null 값을 가질 수 있음. null 값을 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 생성됨.

참조 변수가 null 값인 경우 참조 변수는 사용할 수 없는데 이러한 null 값을 가진 참조 변수를 사용할 경우 NullPointerException이 발생함.



## String 타입

문자열 타입을 의미하는 String 타입의 경우 문자열을 String 객체로 생성하고 String 변수는 객체를 참조함.

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있음.

문자열 리터럴이 아닌 new 연산자를 사용해 String 객체를 직접 생성할 수도 있는데, 이 경우에는 동일한 리터럴일지라도 서로 다른 String 객체를 생성하여 참조함.



## 배열 타입

배열은 같은 타입의 데이터를 연속된 공간에 나열시키고 각 데이터에 인덱스를 부여해 놓은 자료구조.

배열 변수는 배열도 객체이므로 참조 변수에 속함. 배열은 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조함.

### 배열 선언

```java
// 타입[] 변수; 또는 타입 변수[];
int[] intArray1;
int intArray2[];
```

### 값 목록으로 배열 생성

```java
// 타입[] 변수 = {값1, 값2, 값3, ...};
String[] names1 = {"Tom", "James", "Hans"};

// 주의할 점으로는 배열 변수를 이미 선언한 후 다른 표현식에서 중괄호를 사용한 배열 생성은 허용되지 않음.
String[] names2;
names2 = {"Tom", "James", "Hans"}; // 컴파일 에러

// 따라서 배열 변수를 미리 선언한 후 값 목록이 나중에 결정되는 상황이라면 다음과 같이 new 연산자를 사용해야 함.
String[] names3;
names3 = new String[] {"Tom", "James", "Hans"};

int result1 = add({10, 20, 30}); // 컴파일 에러
int result2 = add(new int[] {10, 20, 30});
```

 ### new 연산자로 배열 생성

```java
// 타입[] 변수 = new 타입[길이];
// 또는 타입[] 변수 = null; 변수 = new 타입[길이];
int[] intArray = new int[5];
```

### 배열 길이

`배열변수.length` 필드를 통해 배열의 길이를 알 수 있음.

### 배열 복사

배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 큰 배열이 필요하다면 새로 만들고 이전 배열로부터 항목 값들을 복사해야 함. 배열 간 항목 값들을 복사하려면 반복문을 사용하거나 `System.arraycopy()` 메서드를 사용하면 됨.

참조 타입 배열의 경우, 배열 복사가 되면 복사되는 값이 객체의 주소이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일함. 이것을 *얕은 복사(shallow copy)*라고 함. 반대로 *깊은 복사(deep copy)*는 참조하는 객체도 별도로 생성하는 것을 뜻함.



## 열거(enum) 타입

데이터 중에는 몇 가지로 한정된 값만을 갖는 경우가 흔히 있는데, 이와 같이 한정된 값만을 갖는 데이터 타입이 열거 타입. 열거 타입은 몇 개의 열거 상수 중에서 하나의 상수를 저장하는 데이터 타입.

### 열거 타입 선언

열거 타입을 선언하기 위해서는 먼저 열거 타입의 이름을 정하고 열거 타입 이름으로 소스 파일(.java)을 생성해야 함. 열거 타입 이름은 관례적으로 파스칼 표기법을 사용함.

```java
public enum Week { MONDAY, TUESDAY, WEDNESDAY, ... }
```

### 열거 타입 변수

```java
// 열거타입 변수;
Week today;

// 열거타입 변수 = 열거타입.열거상수;
Week today = Week.SUNDAY;
```

열거 상수는 열거 객체로 생성됨.

열거 타입 변수는 스택 영역에 생성되며, 저장되는 값은 열거 상수가 참조하는 객체의 주소임. 따라서 열거 상수와 열거 타입 변수는 서로 같은 객체를 참조함.

### 열거 객체의 메서드

모든 열거 타입은 컴파일 시 java.lang.Enum 클래스를 상속하게 되어 있음. 따라서 Enum 클래스의 메서드를 사용할 수 있음.

| 리턴 타입  | 메서드(매개변수)            | 설명                    |
| ------ | -------------------- | --------------------- |
| String | name()               | 열거 객체의 문자열을 리턴        |
| int    | ordinal()            | 열거 객체의 순번(0부터 시작)을 리턴 |
| int    | compareTo()          | 열거 객체를 비교해서 순번 차이를 리턴 |
| 열거 타입  | valueOf(String name) | 주어진 문자열의 열거 객체를 리턴    |
| 열거 배열  | values()             | 모든 열거 객체들을 배열로 리턴     |

